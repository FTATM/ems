<script>
    let meters = [];
    let types = [];
    let filterDatas = [];
    document.addEventListener("DOMContentLoaded", async () => {
        await prepareData();
    });

    async function prepareData() {
        showLoading();
        await fetchAll();

        await loadingChart();
        hideLoading();
    }

    async function fetchAll() {
        let response = await fetch('../config/fetch-meters.php');
        let json = await response.json();
        meters = json;

        let responsetype = await fetch("../config/fetch-data_type.php");
        let jsontype = await responsetype.json();
        types = jsontype;

    }

    async function CheckDateData() {
        let location = document.getElementById('select-location');
        let building = document.getElementById('select-building');
        let from = document.getElementById('datetime-from');
        let to = document.getElementById('datetime-to');

        // กรณี input เป็น date เฉย ๆ (เช่น type="date")
        const fromDate = new Date(from.value + " 00:00:00");  // เริ่มต้นวัน
        const toDate = new Date(to.value + " 23:59:59");    // สิ้นสุดวัน

        const filterdatas = Object.values(meters).map(meter => {
            const filteredValueColumn = {};
            Object.entries(meter.data).map(([colName, rows]) => {
                filteredValueColumn[colName] = Object.values(rows).filter(row => {
                    let rawDate = row.create_date;

                    // แทนที่ "/" เป็น "-" เพื่อให้ new Date() รองรับได้
                    rawDate = rawDate.replace(/\//g, "-");
                    rawDate = rawDate.split(" ")[0];
                    const d2 = new Date(rawDate);
                    return d2 >= fromDate && d2 <= toDate;
                });
            })

            return {
                ...meter,
                data: filteredValueColumn
            };
        });

        console.log("Filter Data : ", filterdatas);
        return filterdatas;
    }

    async function loadingChart() {
        let Data = [];
        filterDatas = await CheckDateData();
        Object.values(filterDatas).forEach(filterData => {
            Data.push(...prepareLinearData(filterData, 1));
        });
        createLinearChart('linear-chart', "TEST", Data);

        ReloadTable();
    }

    function ReloadTable() {
        if (filterDatas.length == 0) {
            console.log('Not found Data PLEASE select new times.');
            return;
        }
        const is_check = document.getElementById('is-table-all-value');
        const count = document.getElementById('select-table-show').value;
        if (is_check.checked) {
            TableData(filterDatas, Object.values(filterDatas[0].data)[0].length);
        } else {
            TableData(filterDatas, parseInt(count));
        }
    }

    function TableData(filterDatas, countShow) {
        let table = document.getElementById('table-data');
        table.innerHTML = `
            <thead>
            </thead>
            <tbody>
            </tbody>`;
        let trh = document.createElement('tr');
        trh.innerHTML = `
            <th>No.</th>
            <th>Create Date</th>
        `;
        types.forEach(type => {
            let th = document.createElement('th');
            th.innerText = type.name;
            trh.appendChild(th);
        });
        table.querySelector('thead').appendChild(trh);
        // filterDatas.forEach(Datameter => {
        var Datameter = filterDatas[0].data;
        // make dictionary to list eiei
        Datameter = Object.values(Datameter);

        //for by length of rows in database from meter 
        // for (let i = 0; i < Datameter[0].length; i++) {
        for (let i = Datameter[0].length - 1; i > (Datameter[0].length - 1) - countShow; i--) {
            let trd = document.createElement('tr');
            trd.innerHTML = `
                <td>${i + 1}</td>
                <td>${Datameter[0][i].create_date}</td>
            `;
            for (let j = 0; j < types.length; j++) {
                const type = types[j];
                let td = document.createElement('td');
                td.textContent = Datameter[j][i].value;
                trd.appendChild(td);
            }
            table.querySelector('tbody').appendChild(trd);
        };

        // });

    }

    function getRandomColor(index) {
        const colors = [
            "#ff6384", "#36a2eb", "#44B530", "#ffce56", "#4bc0c0",
            "#9966ff", "#ff9f40", "#c9cbcf", "#00b894", "#e17055",
            "#D5AAFF", "#A0E7E5", "#B4F8C8", "#FBE7C6", "#FFABAB",
            "#FFC3A0", "#D0F4DE", "#A9DEF9", "#E4C1F9", "#F694C1"
        ];
        return colors[index];
    }

    function prepareLinearData(filterData, columnIndex) {
        const chartData = [];

        const rawData = filterData.data?.[columnIndex];

        if (rawData && Array.isArray(rawData)) {
            const dataPoints = rawData.map(row => ({
                x: new Date(row.create_date),
                y: parseFloat(row.value) || 0
            }));

            chartData.push({
                type: "splineArea",
                axisYType: "secondary",
                name: `${filterData.name}`,
                showInLegend: true,
                markerSize: 0,
                yValueFormatString: "#,##0.##",
                dataPoints: dataPoints,
                color: getRandomColor(columnIndex)
            });
        }

        return chartData;
    }

    function createLinearChart(idContainer, title, dataPointsLinear) {
        const chart = new CanvasJS.Chart(idContainer, {
            theme: 'dark2',
            backgroundColor: "#1B1C1D",
            title: { text: title },
            axisX: { valueFormatString: "HH:mm:ss" },
            axisY2: {
                title: "Median List Price",
                prefix: "",
                suffix: ""
            },
            toolTip: { shared: true },
            legend: {
                cursor: "pointer",
                verticalAlign: "top",
                horizontalAlign: "center",
                dockInsidePlotArea: true,
                itemclick: toggleDataSeries
            },
            data: dataPointsLinear
        });
        chart.render();

        window.myChart = chart; // ✅ เก็บไว้ใช้ภายนอก
    }

    function toggleDataSeries(e) {
        if (typeof (e.dataSeries.visible) === "undefined" || e.dataSeries.visible) {
            e.dataSeries.visible = false;
        } else {
            e.dataSeries.visible = true;
        }
        e.chart.render(); // ✅ ใช้ chart จาก even
    }
</script>