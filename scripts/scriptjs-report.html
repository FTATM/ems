<script>
    let meters = [];
    let types = [];
    let locations = [];
    let groups = [];
    let filtermeters = [];
    let filterDatas = [];

    const typeMeterID = "<?=$_SESSION['tid'];?>";
    const groupID = "<?=$_SESSION['gid'];?>";

    document.addEventListener("DOMContentLoaded", async () => {
        await process();
    });

    async function process() {
        showLoading();
        await fetchAll();
        await filterMeters();
        loadingChart();
        hideLoading();
    }

    async function fetchAll() {
        let response = await fetch('../config/fetch-meters.php');
        let json = await response.json();
        meters = json.data;

        let responsetype = await fetch("../config/fetch-data_type.php");
        let jsontype = await responsetype.json();
        types = jsontype.data;

        let responseLocation = await fetch("../config/fetch-locations.php");
        let jsonLocation = await responseLocation.json();
        locations = jsonLocation.data;

        let responsegroup = await fetch("../config/fetch-groups.php");
        let jsongroup = await responsegroup.json();
        groups = jsongroup.data;

    }

    function createSelect(id, Values, selectFirst = false) {
        if (!Values) {
            alertMessages('error', "No data", "No data for create select please try again.");
            return;
        }
        let select = document.getElementById(id);
        let first = Values[0];
        select.innerHTML = `<option value = "none">-- Please select --</option>`;
        Values.forEach(value => {
            let option = document.createElement('option');
            option.value = value.id;
            option.textContent = value.name;
            option.selected = selectFirst ? value.id === first.id ? "selected" : "" : "";
            select.appendChild(option);
        });
    }

    async function filterMeters() {
        filtermeters = Object.values(meters).filter(m => {
            return m.group_id === groupID && m.meter_type_id === typeMeterID;
        });
        createSelect('select-meter-show', filtermeters, true);
        await filterDataInMeters();
    }

    function filterDataInMeters() {

        let from = document.getElementById('datetime-from');
        let to = document.getElementById('datetime-to');

        const fromDate = new Date(from.value + " 00:00:00");  // เริ่มต้นวัน
        const toDate = new Date(to.value + " 23:59:59");    // สิ้นสุดวัน

        filterDatas = Object.values(filtermeters).map(meter => {
            const filteredValueColumn = {};
            Object.entries(meter.data).map(([colName, rows]) => {
                filteredValueColumn[colName] = Object.values(rows).filter(row => {
                    let rawDate = row.create_date;
                    rawDate = rawDate.replace(/\//g, "-");
                    rawDate = rawDate.split(" ")[0];
                    const d2 = new Date(rawDate);
                    return d2 >= fromDate && d2 <= toDate;
                });
            })

            return {
                ...meter,
                data: filteredValueColumn
            };
        });
        loadingChart();
    }

    async function loadingChart() {
        let Data = [];
        if (Object.values(filterDatas).length == 0) {
            alertMessages('warning', 'Warning', 'No meter data available for the current selection. Please choose a different time range.', 3000);
            return;
        }
        let selectMeter = parseInt(document.getElementById('select-meter-show').value - 1);

        Data.push(...prepareLinearData(filterDatas[selectMeter], 1));
        createLinearChart('linear-chart', Data);

        ReloadTable();
    }

    function ReloadTable() {
        const is_check = document.getElementById('is-table-all-value');
        const count = document.getElementById('select-table-show').value;
        if (is_check.checked) {
            TableData(filterDatas, Object.values(filterDatas[0].data)[0].length);
        } else {
            TableData(filterDatas, parseInt(count));
        }
    }

    function TableData(filterDatas, countShow) {
        let table = document.getElementById('table-data');
        table.innerHTML = ` <thead> </thead> <tbody> </tbody>`;
        let trh = document.createElement('tr');
        trh.innerHTML = ` <th>No.</th> <th>Create Date</th> `;

        let selectMeter = parseInt(document.getElementById('select-meter-show').value - 1);

        types.forEach(type => {
            let th = document.createElement('th');
            th.className = "text-nowrap";
            th.innerText = type.name;
            trh.appendChild(th);
        });

        table.querySelector('thead').appendChild(trh);
        if (Object.values(filterDatas[selectMeter].data)[0].length == 0) {
            alertMessages('warning', 'Warning', 'No meter data available for the current selection. Please choose a different time range.', 3000);
            return;
        }
        var Datameter = filterDatas[selectMeter].data;
        Datameter = Object.values(Datameter);

        //for by length of rows in database from meter 
        // for (let i = 0; i < Datameter[0].length; i++) {
        for (let i = Datameter[0].length - 1; i > (Datameter[0].length - 1) - countShow; i--) {
            let trd = document.createElement('tr');
            trd.innerHTML = `
                <td>${i + 1}</td>
                <td>${Datameter[0][i].create_date}</td>
            `;
            for (let j = 0; j < types.length; j++) {
                let td = document.createElement('td');
                let val = Datameter[j]?.[i]?.value;
                td.textContent = (val === undefined || isNaN(val)) ? '-' : val;
                trd.appendChild(td);
            }
            table.querySelector('tbody').appendChild(trd);
        };

        // });

    }

    function getRandomColor(index) {
        const colors = [
            "#ff6384", "#36a2eb", "#44B530", "#ffce56", "#4bc0c0",
            "#9966ff", "#ff9f40", "#c9cbcf", "#00b894", "#e17055",
            "#D5AAFF", "#A0E7E5", "#B4F8C8", "#FBE7C6", "#FFABAB",
            "#FFC3A0", "#D0F4DE", "#A9DEF9", "#E4C1F9", "#F694C1"
        ];
        return colors[index];
    }

    function prepareLinearData(filterData, columnIndex) {
        const chartData = [];
        const rawData = filterData.data?.[columnIndex];

        if (rawData && Array.isArray(rawData)) {
            const dataPoints = rawData.map(row => ({
                x: new Date(row.create_date),
                y: parseFloat(row.value) || 0
            }));

            chartData.push({
                type: "splineArea",
                axisYType: "secondary",
                name: `${filterData.name}`,
                showInLegend: true,
                markerSize: 0,
                yValueFormatString: "#,##0.##",
                dataPoints: dataPoints,
                color: getRandomColor(columnIndex)
            });
        }

        return chartData;
    }

    function createLinearChart(idContainer, dataPointsLinear) {
        const chart = new CanvasJS.Chart(idContainer, {
            theme: 'dark2',
            backgroundColor: "#1B1C1D",
            axisX: { valueFormatString: "HH:mm:ss" },
            axisY2: {
                title: "Median List Price",
                prefix: "",
                suffix: ""
            },
            toolTip: { shared: true },
            legend: {
                cursor: "pointer",
                verticalAlign: "top",
                horizontalAlign: "center",
                dockInsidePlotArea: true,
                itemclick: toggleDataSeries
            },
            data: dataPointsLinear
        });
        chart.render();

        window.myChart = chart; // ✅ เก็บไว้ใช้ภายนอก
    }

    function toggleDataSeries(e) {

        if (typeof (e.dataSeries.visible) === "undefined" || e.dataSeries.visible) {
            e.dataSeries.visible = false;
        } else {
            e.dataSeries.visible = true;
        }
        e.chart.render(); // ✅ ใช้ chart จาก even
    }

    function ExportCSV() {
        if (!filterDatas || filterDatas.length === 0) {
            alert("ไม่มีข้อมูลสำหรับ Export");
            return;
        }
        let csvContent = 'ID, meter, create_date,';
        //ใส่ header csv
        csvContent += types.map(t => t.name).join(",") + "\n";
        // types.forEach(type => {
        //     th.innerText = type.name;
        // });
        //ใส่ data csv
        filterDatas.forEach(meter => {
            const Datameter = Object.values(meter.data);
            for (let i = 0; i < Datameter[0].length; i++) {
                csvContent += i + 1 + "," + meter.name + "," + Datameter[0][i].create_date + ",";
                for (let j = 0; j < types.length; j++) {
                    const type = types[j];
                    csvContent += Datameter[j][i].value + (j == types.length - 1 ? "" : ",");
                }
                csvContent += '\n';
            };
        });

        // ใส่ BOM \uFEFF เพื่อให้ Excel รองรับภาษาไทย
        const blob = new Blob(["\uFEFF" + csvContent], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);

        const link = document.createElement("a");
        link.href = url;
        let now = new Date();
        let timestamp = now.getFullYear() + "-" +
            String(now.getMonth() + 1).padStart(2, '0') + "-" +
            String(now.getDate()).padStart(2, '0') + "_" +
            String(now.getHours()).padStart(2, '0') + "-" +
            String(now.getMinutes()).padStart(2, '0') + "-" +
            String(now.getSeconds()).padStart(2, '0');

        link.download = "CSV All Meters " + timestamp + ".csv";
        link.click();

        URL.revokeObjectURL(url); // cleanup
    }

    function ExportExcel() {
        if (!filterDatas || filterDatas.length === 0) {
            alert("ไม่มีข้อมูลสำหรับ Export");
            return;
        }

        // เตรียม header
        let headers = ["ID", "meter", "create_date", ...types.map(t => t.name)];

        // เตรียม rows
        let rows = [];
        filterDatas.forEach(meter => {
            const Datameter = Object.values(meter.data);
            for (let i = 0; i < Datameter[0].length; i++) {
                let row = [];
                row.push(i + 1); // ID
                row.push(meter.name); // meter
                row.push(Datameter[0][i].create_date); // create_date
                for (let j = 0; j < types.length; j++) {
                    row.push(Datameter[j][i].value);
                }
                rows.push(row);
            }
        });

        // สร้าง worksheet + workbook
        let ws_data = [headers, ...rows];
        let ws = XLSX.utils.aoa_to_sheet(ws_data);
        let wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "Data");

        // ตั้งชื่อไฟล์ (ใส่ timestamp)
        let now = new Date();
        let timestamp = now.getFullYear() + "-" +
            String(now.getMonth() + 1).padStart(2, '0') + "-" +
            String(now.getDate()).padStart(2, '0') + "_" +
            String(now.getHours()).padStart(2, '0') + "-" +
            String(now.getMinutes()).padStart(2, '0') + "-" +
            String(now.getSeconds()).padStart(2, '0');

        XLSX.writeFile(wb, "Excel_All_Meters_" + timestamp + ".xlsx");
    }

    async function sendExportToEmail(type = "excel") {
        if (!filterDatas || filterDatas.length === 0) {
            alert("ไม่มีข้อมูลสำหรับส่งอีเมล");
            return;
        }

        let element = document.getElementById(type);
        element.disabled = true;
        alertMessages('info', 'Export Process', 'กำลังส่งไฟล์ โปรดรอซักครู่...', 3000, true);

        let content, fileName, mimeType;
        const form = new FormData();
        form.append("email", document.getElementById("email").value);

        if (type === "csv") {
            let csvContent = 'ID,meter,create_date,' + types.map(t => t.name).join(",") + "\n";
            filterDatas.forEach(meter => {
                const Datameter = Object.values(meter.data);
                for (let i = 0; i < Datameter[0].length; i++) {
                    csvContent += (i + 1) + "," + meter.name + "," + Datameter[0][i].create_date + ",";
                    for (let j = 0; j < types.length; j++) {
                        csvContent += Datameter[j][i].value + (j === types.length - 1 ? "" : ",");
                    }
                    csvContent += "\n";
                }
            });
            content = "\uFEFF" + csvContent;
            fileName = "Export_All_Meters.csv";
            mimeType = "text/csv";
            form.append("file", new Blob([content], { type: mimeType }), fileName);

        } else {
            // Excel
            let headers = ["ID", "meter", "create_date", ...types.map(t => t.name)];
            let rows = [];
            filterDatas.forEach(meter => {
                const Datameter = Object.values(meter.data);
                for (let i = 0; i < Datameter[0].length; i++) {
                    let row = [i + 1, meter.name, Datameter[0][i].create_date];
                    for (let j = 0; j < types.length; j++) {
                        row.push(Datameter[j][i].value);
                    }
                    rows.push(row);
                }
            });

            let ws = XLSX.utils.aoa_to_sheet([headers, ...rows]);
            let wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Data");

            let wbout = XLSX.write(wb, { bookType: "xlsx", type: "array" });
            let blob = new Blob([wbout], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
            fileName = "Export_All_Meters.xlsx";
            form.append("file", blob, fileName);
        }


        try {
            const res = await fetch("../config/sendToEmail.php", {
                method: "POST",
                body: form
            });
            const text = await res.text();
            console.log(text);
        } catch (err) {
            console.error(err);
            alert("เกิดข้อผิดพลาดในการส่งไฟล์ไปอีเมล");
        }
        element.disabled = false;
        alertMessages('success', 'Export Process', 'ส่งไฟล์ไปยัง '+ document.getElementById('email').value + ' สำเร็จ', 3000, true);
    }


</script>