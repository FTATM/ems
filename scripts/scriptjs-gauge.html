<script>
    let meters = [];
    let types = [];
    let locations = [];
    let buildings = [];
    let rooms = [];
    let refreshIntervalId; // เก็บ interval id
    const gaugeInstances = {};
    document.addEventListener("DOMContentLoaded", async () => {
        await prepareData();
    });

    async function prepareData() {
        showLoading();
        await fetchAll();
        await generateSelect('select-meters', Object.values(meters));
        await generateGauge();
        setRefreshTime();
        hideLoading();
    }

    async function fetchAll() {

        let response = await fetch('../config/fetch-meters.php');
        let json = await response.json();
        meters = json.data;

        let responsetype = await fetch("../config/fetch-data_type.php");
        let jsontype = await responsetype.json();
        types = jsontype.data;

        let responseLocation = await fetch("../config/fetch-locations.php");
        let jsonLocation = await responseLocation.json();
        locations = jsonLocation.data;

        let responsebuilding = await fetch("../config/fetch-buildings.php");
        let jsonbuilding = await responsebuilding.json();
        buildings = jsonbuilding.data;

        let responseRoom = await fetch("../config/fetch-rooms.php");
        let jsonRoom = await responseRoom.json();
        rooms = jsonRoom.data;
    }

    async function generateGauge() {
        const listGauge = document.getElementById('list-gauge');
        listGauge.innerHTML = ''; // Clear previous gauges
        Object.values(types).forEach(type => {
            let gaugediv = document.createElement('canvas');
            gaugediv.id = 'gauge_' + type.id;
            listGauge.appendChild(gaugediv);
            gaugeGenerate('gauge_' + type.id, type.name, type.name, 0, 0, type.maxvaluecolumn, 5);
        });
        generateDataList();
    }

    async function generateDataList() {
        let listdata = document.getElementById('list-data');
        meterID = document.getElementById('select-meters').value;
        listdata.innerHTML = `
        <div class="w-100 p-2 text-center">
            <h4><?=$lang['alltype']?></h4>
        </div>`; // เคลียร์ข้อมูลเดิมก่อนสร้างใหม่
        console.log(meterID);

        types.forEach($row => {
            let div = document.createElement('div');
            div.className = "d-flex w-100";
            let label = document.createElement('label');
            label.className = "w-50 fs-6 text-end pe-3";
            label.textContent = $row.name;
            let input = document.createElement('input');
            input.id = "type-" + $row.id;
            input.className = "w-50 form-control form-control-sm border-opacity-50 disabled";
            input.value = "0.00";
            // input.value = meters[meterID].data[$row.id][meters[meterID].data[$row.id].length - 1].value;

            div.appendChild(label);
            div.appendChild(input);
            listdata.appendChild(div);
        });
    }

    function generateSelect(id, datas) {
        let select = document.getElementById(id);
        // select.innerHTML = `<option value="0">-- <?=$lang['select']?> --</option>`;
        datas.forEach(row => {
            let option = document.createElement('option');
            option.value = row.id;
            option.textContent = `[${row.id}] ${row.name}`;
            option.selected = datas[0].id === row.id ? true : false;
            select.appendChild(option);
        });
    }

    function checkTimeChange() {
        const listGauge = document.getElementById('list-gauge');
        const time = document.getElementById('select-time');
        meterID = document.getElementById('select-meters').value;
        if (!Number(time.value)) {
            console.log(time.value);
            alertMessages('error', 'Error', 'Time picker Data not found.');
            return;
        }
        let now = new Date();
        let selectedDateTime;
        if (time.value === "0") {
            selectedDateTime = new Date(1970, 0, 1);
        } else if (time.value === "1") {
            selectedDateTime = new Date(now.getTime() - 0.5 * 60000);
        } else {
            selectedDateTime = new Date(now.getTime() - parseInt(time.value, 10) * 60000);
        }
        let filtermeter = filterData(meterID, selectedDateTime);
        Object.entries(filtermeter.data).forEach(([key, values]) => {
            let maxvalue = parseFloat(values[0]?.value) || 0;
            let minvalue = parseFloat(values[0]?.value) || 0;
            let lastValue = parseFloat(values[values.length - 1]?.value) || "00.00";
            values.forEach(row => {
                let val = parseFloat(row.value);
                maxvalue = val > maxvalue ? val : maxvalue;
                minvalue = val < minvalue ? val : minvalue;
            });
            document.getElementById('type-' + key).value = lastValue;
            gaugeGenerate('gauge_' + key, types[key - 1].name, types[key - 1].name, lastValue);
        });
    }

    function filterData(id, selectedDateTime) {
        const filteredValueColumn = {};
        Object.entries(meters[id].data).map(([colName, rows]) => {
            filteredValueColumn[colName] = Object.values(rows).filter(row => {
                let rawDate = row.create_date;
                rawDate = rawDate.replace(/\//g, "-");
                const d2 = new Date(rawDate);
                return d2 >= selectedDateTime;
            });
        })
        return {
            ...meters[id],
            data: filteredValueColumn
        };
    }

    function gaugeGenerate(id, title, unitname, value = 0, minValue = 0, maxValue = 200, step = 10, width = 225, height = 225) {
        if (id === undefined || unitname === undefined) {
            console.error(`ID:${id} or title:${title} or unitname:${unitname} are required for gauge generation.`);
            alertMessages('error', 'Error', 'ID and unit name are required for gauge generation.');
            return;
        }
        let majorTicks = [];
        for (let i = minValue; i <= maxValue; i += maxValue / step) {
            majorTicks.push(parseFloat(i).toFixed(1).toString());
        }
        if (!gaugeInstances[id]) {
            gaugeInstances[id] = new RadialGauge({
                renderTo: id,
                title: title,
                width: width,
                height: height,
                // units: unitname,
                minValue: minValue,
                maxValue: maxValue,
                majorTicks: majorTicks,
                minorTicks: 2,
                highlights: [
                    { from: maxValue - (maxValue / 3), to: maxValue, color: "rgba(200, 50, 50, .75)" }
                ],
                value: value,
                animationDuration: 500,
                animationRule: "linear",
                colorPlate: "rgba(0,0,0,.1)",
                colorMajorTicks: "#fff",
                colorMinorTicks: "#fff",
                colorTitle: "#fff",
                colorUnits: "#fff",
                colorNumbers: "#fff",
                colorNeedle: "#fff",
                needleWidth: 1,
                needleCircleSize: 4,
            }).draw();
        } else {
            gaugeInstances[id].value = value;
        }
    }

    function setRefreshTime() {
        const inputRefresh = document.getElementById('input-refresh');
        const refreshTime = parseInt(inputRefresh.value, 10);
        if (isNaN(refreshTime) || refreshTime < 1 || refreshTime > 60) {
            alertMessages('error', 'Error', 'Please enter a valid refresh time between 1 and 30 seconds.');
            return;
        }
        // เคลียร์ interval เก่า
        clearInterval(refreshIntervalId);

        console.log("Setting refresh time to:", refreshTime);

        // ตั้ง interval ใหม่
        refreshIntervalId = setInterval(() => {
            checkTimeChange();
        }, refreshTime * 1000);
    }

</script>