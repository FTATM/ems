<script>
    let meters = [];
    let types = [];
    let locations = [];
    let groups = [];
    let refreshIntervalId; // เก็บ interval id
    const gaugeInstances = {};

    const typeMeterID = "<?=$_SESSION['tid'];?>";
    const groupID = "<?=$_SESSION['gid'];?>";

    let ftloaded = false;
    document.addEventListener("DOMContentLoaded", async () => {
        ftloaded = true;
        await process();
    });

    async function process() {
        showLoading();
        await fetchAll();
        await generateSelect('select-meters', Object.values(meters));
        await generateGauge();
        setRefreshTime();
        hideLoading();
    }

    async function fetchAll() {
        meters = await fetchDataInMeters();

        let responsetype = await fetch("../config/fetch-data_type.php");
        let jsontype = await responsetype.json();
        types = jsontype.data;

        let responseLocation = await fetch("../config/fetch-locations.php");
        let jsonLocation = await responseLocation.json();
        locations = jsonLocation.data;

        let responsegroup = await fetch("../config/fetch-groups.php");
        let jsongroup = await responsegroup.json();
        groups = jsongroup.data;

    }

    async function fetchDataInMeters() {
        let formfilter = new FormData();
        formfilter.append("tid", typeMeterID);
        formfilter.append("gid", groupID);

        try {
            const res = await fetch("../config/fetch-meters-filter.php", {
                method: "POST",
                body: formfilter
            });
            const result = await res.json();
            return result.data;
        } catch (e) {
            console.error('error unknown file fetch-meters-filter.php : ', e.message);
            alertMessages('error', 'พบปัญหา', 'เกิดข้อผิดพลาดในการทำงานของสคริปต์ fetch-meters-filter กรุณาคัดลอกข้อความนี้และส่งต่อให้ผู้ดูแลระบบ', 4000, true);
            return [];
        }
    }

    async function generateGauge() {
        const listGauge = document.getElementById('list-gauge');
        listGauge.innerHTML = ''; // Clear previous gauges
        meterID = document.getElementById('select-meters').value;
        let selectedMeter = Object.values(meters).find(m => m.id === parseInt(meterID));
        Object.entries(selectedMeter.data).forEach(([key, value]) => {
            let typeSelect = types.find(t => t.id === key);
            let max = 0;
            value.forEach(row => {
                max = parseFloat(row.value) > max ? parseFloat(row.value) : max;
            })
            let gaugediv = document.createElement('canvas');
            gaugediv.id = 'gauge_' + typeSelect.id;
            listGauge.appendChild(gaugediv);
            gaugeGenerate('gauge_' + typeSelect.id, typeSelect.name, typeSelect.name, 0, 0, max * 1.2, 5);
        });
        generateDataList();
    }

    async function generateDataList() {
        let listdata = document.getElementById('list-data');
        meterID = document.getElementById('select-meters').value;
        listdata.innerHTML = `
        <div class="w-100 p-2 text-center">
            <h4><?=$lang['alltype']?></h4>
        </div>`;

        types.forEach($row => {
            let div = document.createElement('div');
            div.className = "d-flex w-100";
            let label = document.createElement('label');
            label.className = "w-50 fs-6 text-end pe-3";
            label.textContent = $row.name;
            let input = document.createElement('input');
            input.id = "type-" + $row.id;
            input.className = "w-50 form-control form-control-sm border-opacity-50 disabled";
            input.value = "0.00";
            // input.value = meters[meterID].data[$row.id][meters[meterID].data[$row.id].length - 1].value;

            div.appendChild(label);
            div.appendChild(input);
            listdata.appendChild(div);
        });
    }

    function generateSelect(id, datas) {
        if (!ftloaded) { return }
        ftloaded = false;
        let select = document.getElementById(id);
        // select.innerHTML = `<option value="0">-- <?=$lang['select']?> --</option>`;
        datas.forEach(row => {
            let option = document.createElement('option');
            option.value = row.id;
            option.textContent = `[${row.id}] ${row.name}`;
            option.selected = datas[0].id === row.id ? true : false;
            select.appendChild(option);
        });
    }

    async function checkTimeChange() {
        meters = await fetchDataInMeters();

        const listGauge = document.getElementById('list-gauge');
        const time = document.getElementById('select-time');
        meterID = document.getElementById('select-meters').value;
        if (!Number(time.value)) {
            console.log(time.value);
            alertMessages('error', 'Error', 'Time picker Data not found.');
            return;
        }
        let now = new Date();
        let selectedDateTime;
        if (time.value === "0") {
            selectedDateTime = new Date(1970, 0, 1);
        } else if (time.value === "1") {
            selectedDateTime = new Date(now.getTime() - 1.5 * 60000);
        } else {
            selectedDateTime = new Date(now.getTime() - parseInt(time.value, 10) * 60000);
        }
        console.log("==> now : ", now.toLocaleTimeString());
        console.log("==> select : ", selectedDateTime.toLocaleTimeString());
        let filtermeter = filterData(meterID, selectedDateTime);
        console.log("Data size : ", filtermeter.data['1'].length);
        Object.entries(filtermeter.data).forEach(([key, values]) => {
            let maxvalue = parseFloat(values[0]?.value) || 0;
            let minvalue = parseFloat(values[0]?.value) || 0;
            let lastValue = parseFloat(values[values.length - 1]?.value) || "00.00";
            values.forEach(row => {
                let val = parseFloat(row.value);
                maxvalue = val > maxvalue ? val : maxvalue;
                minvalue = val < minvalue ? val : minvalue;
            });
            document.getElementById('type-' + key).value = lastValue;
            gaugeGenerate('gauge_' + key, types[key - 1].name, types[key - 1].name, lastValue);
        });
    }

    function filterData(id, selectedDateTime) {
        const filteredValueColumn = {};
        let meterSelected = Object.values(meters).find(m => { return m.id === parseInt(id) });
        Object.entries(meterSelected.data).map(([colName, rows]) => {
            filteredValueColumn[colName] = Object.values(rows).filter(row => {
                let rawDate = row.create_date;
                rawDate = rawDate.replace(/\//g, "-");
                const d2 = new Date(rawDate);
                return d2 >= selectedDateTime;
            });
        })
        return {
            ...meterSelected,
            data: filteredValueColumn
        };
    }

    function gaugeGenerate(id, title, unitname, value = 0, minValue = 0, maxValue = 200, step = 10, width = 225, height = 225) {
        if (id === undefined || unitname === undefined) {
            console.error(`ID:${id} or title:${title} or unitname:${unitname} are required for gauge generation.`);
            alertMessages('error', 'Error', 'ID and unit name are required for gauge generation.');
            return;
        }
        let majorTicks = [];
        for (let i = minValue; i <= maxValue; i += maxValue / step) {
            majorTicks.push(parseFloat(i).toFixed(1).toString());
        }
        if (!gaugeInstances[id]) {
            gaugeInstances[id] = new RadialGauge({
                renderTo: id,
                title: title,
                width: width,
                height: height,
                // units: unitname,
                minValue: minValue,
                maxValue: maxValue,
                majorTicks: majorTicks,
                minorTicks: 2,
                highlights: [
                    { from: maxValue - (maxValue / 3), to: maxValue, color: "rgba(200, 50, 50, .75)" }
                ],
                value: value,
                animationDuration: 1000,
                animationRule: "linear",
                colorPlate: "rgba(0,0,0,.1)",
                colorMajorTicks: "#fff",
                colorMinorTicks: "#fff",
                colorTitle: "#fff",
                colorUnits: "#fff",
                colorNumbers: "#fff",
                colorNeedle: "#fff",
                needleWidth: 1,
                needleCircleSize: 4,
            }).draw();
        } else {
            gaugeInstances[id].value = value;
        }
    }

    function setRefreshTime() {
        const inputRefresh = document.getElementById('input-refresh');
        const refreshTime = parseInt(inputRefresh.value, 10);
        if (isNaN(refreshTime) || refreshTime < 1 || refreshTime > 60) {
            alertMessages('error', 'Error', 'Please enter a valid refresh time between 1 and 30 seconds.');
            return;
        }
        // เคลียร์ interval เก่า
        clearInterval(refreshIntervalId);

        console.log("Setting refresh time to:", refreshTime);

        // ตั้ง interval ใหม่
        refreshIntervalId = setInterval(() => {
            checkTimeChange();
        }, refreshTime * 1000);
    }

</script>